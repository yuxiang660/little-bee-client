{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/6/2020-02-23---How-to-Recapture-Algorithm/","result":{"data":{"markdownRemark":{"id":"f30149f4-768e-5c37-b503-541b135538a7","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 800px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/b5a09/leet-code.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.64705882352941%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABmklEQVQoz5WRO0vDUBTHz1WhDjooWjtY6gMEN90cKiguUsVBCTSPNqZJk6ZpTZO0iQ90EHyAQhUUUSdBHAQRdFBEcHDwG7nGc1NaSjt54Mf/vO/NDUDDOsEq5iAlcJDJZEAURdA0DQRBCOB5nnAcR6rVM0in08GEwAuE1mgfNWldohIKIf31tVu7+6DrOsEmomoqgRaTZZnk83lClca+74OqqiSbVWoNM6PwcMnAEvVTHDPcuiCRSHSxLDvAc9wk3nCquZZMJoeaY/plsKPMsb8fklE9vwgLQmo+m5UjeLqoKEocdQ2bViVJMvEJlhiG6cV4BfOzFMx7qCyymstpncHWh7vrxZ/nk9PXp/sJTdMXTHODKRQKN4iNXCFWsVjkTdNcLpVK0+jLmNORHPoi6iVyYBhGd7DwNtWx579AnPrbrhVzHGfcdd0Rb9PrcSuVGDJYLpfDtm1HkTH0sV7pR40iEc/z+irYR+cd2wkeNXjcu8f3th/wH/t++wKjYNQC/3M4WGZZNsFbBFiWBQ2t0VajubpP548Pj+APLZaiMNzjA+IAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/ba381/leet-code.webp 200w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/7f61c/leet-code.webp 400w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/d00b9/leet-code.webp 800w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/92f8c/leet-code.webp 1200w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/90e3c/leet-code.webp 1360w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/772e8/leet-code.png 200w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/e17e5/leet-code.png 400w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/5a190/leet-code.png 800w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/c1b63/leet-code.png 1200w,\n/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/b5a09/leet-code.png 1360w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/little-bee-client/static/9015a8fc65ab1b9f21dbc9031f09c17e/5a190/leet-code.png\"\n          alt=\"leet-code\"\n          title=\"leet-code\"\n          loading=\"lazy\"\n          style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<h1 id=\"why\" style=\"position:relative;\"><a href=\"#why\" aria-label=\"why permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why</h1>\n<p>大多数人都有过这样的体会：刷过一系列算法题，并且对常见的解题思路已经了然于胸，可一段时间后，以前的算法题再次变得很陌生。</p>\n<p>这一方面是因为很多算法的解题思路巧妙但不直观，另一方面也是因为平时的编码工作并不经常涉及这些巧妙的算法。</p>\n<p>为了快速回忆起遗忘的常见算法，这篇“蜂博客”罗列了常见算法的核心思想。</p>\n<h2 id=\"为什么选择leetcode为例子阐述算法？\" style=\"position:relative;\"><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9leetcode%E4%B8%BA%E4%BE%8B%E5%AD%90%E9%98%90%E8%BF%B0%E7%AE%97%E6%B3%95%EF%BC%9F\" aria-label=\"为什么选择leetcode为例子阐述算法？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>为什么选择\"LeetCode\"为例子阐述算法？</h2>\n<p>\"LeetCode\"是一个比较完善的在线题库，有以下几个优势：<br></p>\n<ul>\n<li>\"LeetCode\"框架设置了输入，用户不需要自己编写输入逻辑，可以集中思考算法逻辑。</li>\n<li>网络中资源丰富，可以找到各种语言的不同解题思路。</li>\n<li>题目描述简洁清晰，可以快速理解题目的意思。</li>\n</ul>\n<h1 id=\"what\" style=\"position:relative;\"><a href=\"#what\" aria-label=\"what permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What</h1>\n<h2 id=\"常用的算法有哪些？\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\" aria-label=\"常用的算法有哪些？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常用的算法有哪些？</h2>\n<ul>\n<li>暴力解法</li>\n<li>深度递归解法</li>\n<li>动态规划解法</li>\n<li>回溯递归解法</li>\n</ul>\n<h2 id=\"常见的数据结构有哪些？\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\" aria-label=\"常见的数据结构有哪些？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常见的数据结构有哪些？</h2>\n<ul>\n<li>数组</li>\n<li>字符串</li>\n<li>链表</li>\n<li>树</li>\n</ul>\n<h1 id=\"how\" style=\"position:relative;\"><a href=\"#how\" aria-label=\"how permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How</h1>\n<h2 id=\"常用的算法是如何实现的？\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F\" aria-label=\"常用的算法是如何实现的？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常用的算法是如何实现的？</h2>\n<ul>\n<li>暴力解法<br>\n暴力解法是最直观的解题思路，但是效率一般不如其他的方法。暴力解法的主体思想是将问题解法的可能性进行分类枚举，并用大量循环结构解出问题的解。本人建议，对于陌生的算法题，可先用暴力解法得出问题的答案，再思考是否有其他更高效的解法。</li>\n<li>深度递归解法<br>\n树的深度遍历包括：前序遍历、中序遍历和后序遍历。三种遍历都可以通过递归，将大问题化解成小问题，并以边界条件终止。深度递归解法类似深度遍历，利用递归将问题拆解，找到终止逻辑，并通过递归缩小问题范围（如同深度遍历，每次递归处理的树都是上次递归的子树）。</li>\n<li>\n<p>动态规划解法<br>\n动态规划是利用小问题的结果，推导出大问题的结果。过程类似数学归纳法。动态规划一般利用一个数组（一维数组或者二维数组）记录每个小问题的结果，利用循环一步一步解出最后的大问题结果。</p>\n<ul>\n<li>动态规划与深度递归的不同点：<br>\n深度递归解法是从大问题入手，找出可以递归的小问题和终止条件。而动态规划是从小问题入手，从小问题的结果，推导出大问题的结果。<br>\n以求“费布拉切数列”<code class=\"language-text\">f(n)</code>问题为例。动态规划解法会依次求出<code class=\"language-text\">f(1)</code>到<code class=\"language-text\">f(n-1)</code>的所有值，再推导出<code class=\"language-text\">f(n)</code>的值。而深度递归解法并不会记录<code class=\"language-text\">f(1)</code>到<code class=\"language-text\">f(n-1)</code>的值，而是\n利用递归直接求出<code class=\"language-text\">f(n)</code>的值。</li>\n</ul>\n</li>\n<li>回溯递归解法<br>\n回溯递归就像走迷宫，走遍所有路径，如果路径错误，就退回上一步，记录所有可行结果。如：<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/39.Combination-Sum/main.cpp\">\"39.Combination-Sum\"</a>和<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/40.Combination-Sum-II/main.cpp\">\"40.Combination-Sum-II\"</a>，为了获取所有可能结果，利用循环加递归，不断枚举可能路径，并通过一个全局变量，记录可行的结果。如果需要缩小枚举范围（如\"40.Combination-Sum-II\"中对重复数据的处理），可添加额外的检查，终止此路径的递归调用。</li>\n</ul>\n<h2 id=\"常见的数据有哪些操作？\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F\" aria-label=\"常见的数据有哪些操作？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常见的数据有哪些操作？</h2>\n<ul>\n<li>\n<p>数组<br>\n对数组最常见的操作是排序，算法的<code class=\"language-text\">C++</code>实现可参考<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/0.Sort/main.cpp\">GitHub</a>。</p>\n<ul>\n<li>\n<p>暴力解法<br>\n排序的暴力解法包括：选择排序，冒泡排序，插入排序等。暴力解法的时间复杂度都是：O(n^2)。其中，冒泡排序和选择排序的最优时间是O(n)。</p>\n<ul>\n<li><strong>选择排序</strong>是最直观的算法，即每次遍历都选出未排序数据中的最小值，并放到已排序数据的末尾。</li>\n<li><strong>冒泡排序</strong>每次遍历也会在已排序数列中增加一个数据，但是不同于选择排序，冒泡排序每次比较都会试图更改数据排列顺序。这个特点就可以优化最优时间。如果一次遍历没有出现数据排列顺序的变化，就表明数据已经排好序，可结束算法。</li>\n<li><strong>插入排序</strong>类似扑克牌整理过程。每次遍历都会从未排序的数据中任意选择一个，插入到已经排序的数据中。如果是已经排序好的数据，不需要插入的动作，只需要一次比较的动作。因此，最优时间是O(n)。</li>\n</ul>\n</li>\n<li>\n<p>递归解法<br>\n排序的递归解法包括：快速排序，归并排序，堆排序。递归解法的时间复杂度都是：O(nlogn)。</p>\n<ul>\n<li><strong>快速排序</strong>将数组根据某个数进行分类，一组数据都小于这个数，另一组数据都大于这个数。这样就可以缩小数据规模，从而利用递归，达到排序的效果。一次分组过程如下，以<code class=\"language-text\">{49 38 65 97}</code>初始数据为例子，选取<code class=\"language-text\">49</code>为比较数字，经过一次归并后，得到两组数据<code class=\"language-text\">{38} 49 {97 65}</code>。继续为此两组数据进行分组，直到分组中的数据只有一个。采用左右逼近比较的方法，进行一次分组。</li>\n<li><strong>归并排序</strong>将两组已经排序好的数组，归并成一组排序数据。类似树的后序遍历，在递归后得到两组排序好的数据，在归并过程中按顺序比较数据大小，组合成一组数据，需注意边界情况。</li>\n<li><strong>堆排序</strong>是三者中最复杂的算法。需要建立二叉树数组模型，并利用递归建立最大堆（所有父节点的值大于其两个子节点的值）。最大堆的根节点就是所有数据中的最大值。取出最大值后，又需要调整剩余数据构建新的最大堆。以此类推，直到最大堆中没有数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>字符串<br>\n对字符串的底层数据结构和数组是一样的，常见的操作如：寻找回文子串，逆序等。大部分问题可以先从暴力解法入手（一般是多层循环），再考虑是否可以优化（如：动态规划，KMP等）。</li>\n<li>\n<p>链表<br>\n对链表的常见操作是<strong>顺序变化</strong>（如：逆序，排序）。</p>\n<ul>\n<li>单向链表<br>\n单向链表最大的特点是只能单向遍历，如果需要从后往前拿数据，就会比较麻烦。常见的做法是结合栈的特点达到从后往前遍历链表。例如<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/143.Reorder-List/List.cpp\">\"143.Reorder-List\"</a>中，就通过<code class=\"language-text\">Stack</code>完成了对单向链表的重组操作。需要注意的是，在对链表操作中，会存在数据个数单双数两种情况，可以先分两种情况考虑，再看看能不能合并。</li>\n</ul>\n</li>\n<li>\n<p>树<br>\n对树的常见操作有：树的遍历（如：广度优先，深度优先）。</p>\n<ul>\n<li>深度遍历<br>\n<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/94_144_145.Binary-Tree-Inorder_Preorder_Postorder-Traversal/main.cpp\">深度遍历</a>分：前序遍历、中序遍历、后序遍历。可用递归方法很方便地实现。也可以结合栈的特点，通过迭代实现。</li>\n<li>广度遍历<br>\n<a href=\"https://github.com/yuxiang660/leetcode/blob/master/code/102.Binary-Tree-Level-Order-Traversal/main.cpp\">广度遍历</a>可用递归的方法完成。也可以结合队列的特点，通过迭代实现。</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/posts/6/2020-02-23---How-to-Recapture-Algorithm/","tagSlugs":["/tag/leet-code/","/tag/algorithm/"],"date":"2020-02-23T00:00:00.000Z"},"frontmatter":{"description":"这是一篇以\"LeetCode\"为例子，概述常见算法的文章。","tags":["LeetCode","Algorithm"],"title":"如何重新拾起遗忘的算法"}}},"pageContext":{"slug":"/posts/6/2020-02-23---How-to-Recapture-Algorithm/"}}}